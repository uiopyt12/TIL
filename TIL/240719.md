# 240719

- **감시** 문제를 풀려고 시도했다.  
  재귀와 백트래킹에 심취한 상태로 이를 통해 풀어보려고 하다가 시간이 무지막지하게 많이 걸리게 되었다.  
https://www.acmicpc.net/problem/15683  
  


```C++
#include <bits/stdc++.h>
#define y first
#define x second
#define info first
#define direction second
using namespace std;


pair<int, int> board[10][10]; // first는 cctv 및 벽 정보, second는 방향을 나타내도록 저장한 변수이다. 1-index로 저장됨 -> 스택을 지역변수로
pair<int, int> cctvCoord[10][10];
int n, m; // 사무실이 n행 m열로 이루어짐을 나타내는 변수이다.
int k; // cctv의 개수를 저장하는 변수이다.
int curBlindSpot; // 사각지대의 개수를 저장하는 변수이다.
int minBlindSpot;

void getBlindSpot()
{
	curBlindSpot = 0;
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			if (board[i][j].info == 0)
				curBlindSpot++;
		}
	}
}

void cctv_1_On(int r, int c, int dir)
{
	switch (dir)
	{
	case 0: // 오른쪽
		c++;
		while (board[r][c].info != -1) // 6은 -1과 같게 처리함
		{
			switch (board[r][c].info % 100)
			{
			case 0:
				board[r][c].info += 100;
				break;
			default: // 1, 2, 3, 4, 5
				break;
			}
			c++; // x좌표 증가
		}
		break;

	case 1: // 아래
		r++;
		while (board[r][c].info != -1) // 6은 -1과 같게 처리함
		{
			switch (board[r][c].info % 100)
			{
			case 0:
				board[r][c].info += 100;
				break;
			default: // 1, 2, 3, 4, 5
				break;
			}
			r++; // y좌표 증가
		}
		break;
			
	case 2: // 왼쪽
		c--;
		while (board[r][c].info != -1) // 6은 -1과 같게 처리함
		{
			switch (board[r][c].info % 100)
			{
			case 0:
				board[r][c].info += 100;
				break;
			default: // 1, 2, 3, 4, 5
				break;
			}
			c--; // x좌표 감소
		}
		break;

	case 3: // 위
		r--;
		while (board[r][c].info != -1) // 6은 -1과 같게 처리함
		{
			switch (board[r][c].info % 100)
			{
			case 0:
				board[r][c].info += 100;
				break;
			default: // 1, 2, 3, 4, 5
				break;
			}
			r--; // y좌표 감소
		}
		break;

	}


}

void cctv_1_Off(int r, int c, int dir)
{
	switch (dir)
	{
	case 0: // 오른쪽
		c++;
		while (board[r][c].info != -1) // 6은 -1과 같게 처리함
		{
			switch (board[r][c].info % 100)
			{
			case 0:
				board[r][c].info = max(0, board[r][c].info - 100);
				break;
			default: // 1, 2, 3, 4, 5
				break;
			}
			c++; // x좌표 증가
		}
		break;

	case 1: // 아래
		r++;
		while (board[r][c].info != -1) // 6은 -1과 같게 처리함
		{
			switch (board[r][c].info % 100)
			{
			case 0:
				board[r][c].info = max(0, board[r][c].info - 100);
				break;
			default: // 1, 2, 3, 4, 5
				break;
			}
			r++; // y좌표 증가
		}
		break;

	case 2: // 왼쪽
		c--;
		while (board[r][c].info != -1) // 6은 -1과 같게 처리함
		{
			switch (board[r][c].info % 100)
			{
			case 0:
				board[r][c].info = max(0, board[r][c].info - 100);
				break;
			default: // 1, 2, 3, 4, 5
				break;
			}
			c--; // x좌표 감소
		}
		break;

	case 3: // 위
		r--;
		while (board[r][c].info != -1) // 6은 -1과 같게 처리함
		{
			switch (board[r][c].info % 100)
			{
			case 0:
				board[r][c].info = max(0, board[r][c].info - 100);
				break;
			default: // 1, 2, 3, 4, 5
				break;
			}
			r--; // y좌표 감소
		}
		break;

	}

}


void setBlindSpot(int cur)
{
	if (cur == k)
	{
		getBlindSpot(); // 마지막에 한번만 검사해도 됨
		minBlindSpot = min(minBlindSpot, curBlindSpot);

		//cout << endl << " board-----------------------------------" << '\n';

		//for (int i = 0; i < 10; i++)
		//{
		//	for (int j = 0; j < 10; j++)
		//	{
		//		printf("%2d ", board[i][j].info);
		//		//cout << board[i][j].info << ' ';
		//	}
		//	cout << endl;
		//}

		//cout << curBlindSpot << "--------------------------: " << endl;


		return;
	}

	for (int i = cur; i < k; i++)
	{
		switch ( board[ cctvCoord[i]->y ][ cctvCoord[i]->x ].info )
		{
		case 1:

			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 0);
			setBlindSpot(cur + 1);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 0);

			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 1);
			setBlindSpot(cur + 1);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 1);

			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 2);
			setBlindSpot(cur + 1);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 2);

			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 3);
			setBlindSpot(cur + 1);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 3);

			break;

		case 2:

			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 0);
			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 2);
			setBlindSpot(cur + 1);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 0);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 2);

			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 1);
			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 3);
			setBlindSpot(cur + 1);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 1);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 3);

			break;

		case 3:

			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 0); // 우하
			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 1);
			setBlindSpot(cur + 1);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 0);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 1);

			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 1); // 좌하
			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 2);
			setBlindSpot(cur + 1);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 1);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 2);

			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 2); // 좌상
			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 3);
			setBlindSpot(cur + 1);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 2);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 3);

			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 3); // 우상
			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 4);
			setBlindSpot(cur + 1);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 3);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 4);

			break;

		case 4:

			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 0); // execpt 3
			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 1);
			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 2);
			setBlindSpot(cur + 1);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 0);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 1);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 2);

			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 0); // execpt 2
			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 1);
			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 3);
			setBlindSpot(cur + 1);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 0);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 1);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 3);

			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 0); // execpt 1
			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 3);
			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 2);
			setBlindSpot(cur + 1);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 0);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 3);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 2);

			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 3); // execpt 0
			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 1);
			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 2);
			setBlindSpot(cur + 1);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 3);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 1);
			cctv_1_Off(cctvCoord[i]->y, cctvCoord[i]->x, 2);

			break;

		case 5:

			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 0); // 그 누구도 제외되지 않는 세계의 완성이다
			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 1);
			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 2);
			cctv_1_On(cctvCoord[i]->y, cctvCoord[i]->x, 3);
			setBlindSpot(cur + 1);

			break;
		}

	}


}


int main()
{
	for (int i = 0; i < 10; i++)
	for (int j = 0; j < 10; j++) 
			board[i][j].info = -1; // 사무실 바깥을 -1로 처리
	//	fill(&board[i][0].info, &board[i][9].info, -1); // 왜 안되지

	cin >> n >> m;
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			cin >> board[i][j].info;
			if (board[i][j].info >= 1 && board[i][j].info <= 5) // cctv인 경우
			{
				cctvCoord[k]->y = i; // . 대신 -> 써도 되나? 배열이라 괜찮나?
				cctvCoord[k]->x = j;
				k++; // cctv의 개수 증가
			}
			else if (board[i][j].info == 0) // 빈 공간인 경우
			{
				minBlindSpot++;
			}
			
			else if (board[i][j].info == 6) // 벽인 경우
			{
				board[i][j].info = -1;
			}

		}
	}
	


	setBlindSpot(0);



	cout << endl << "last board-----------------------------------" << '\n';

	for (int i = 0; i < 10; i++)
	{
		for (int j = 0; j < 10; j++)
		{
			printf("%2d ", board[i][j].info);
			//cout << board[i][j].info << ' ';
		}
		cout << endl;
	}

	cout << "min blind spot : " << minBlindSpot << endl;
}
```